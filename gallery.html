<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Gallery | Astro Kabuto</title>
  <link rel="stylesheet" href="style.css">
</head>

<body>
  <header class="header">
    <a class="brand" href="index.html">
      <strong>Astro Kabuto</strong><br>
      <small>兜丸の成長記録サイト</small>
    </a>
  </header>

  <main class="container">
    <h1>Gallery</h1>
    <p class="sub">兜丸の写真記録</p>

    <div class="grid">
      <img class="gimg"
     src="images/gallery/2026-01-09_kabuto (1).jpg"
     alt="兜丸"
     loading="lazy" decoding="async"
     data-cultivar="兜丸（Astrophytum asterias）"
     data-date="2026-01-09"
     data-author="kiji">


     <img class="gimg" src="images/gallery/2026-01-09_kabuto (2).jpg" alt="" loading="lazy" decoding="async">
      <img class="gimg" src="images/gallery/2026-01-09_kabuto (3).jpg" alt="" loading="lazy" decoding="async">
      <img class="gimg" src="images/gallery/2026-01-09_kabuto (4).jpg" alt="" loading="lazy" decoding="async">
      <img class="gimg" src="images/gallery/2026-01-09_kabuto (5).jpg" alt="" loading="lazy" decoding="async">
      <img class="gimg" src="images/gallery/2026-01-09_kabuto (6).jpg" alt="" loading="lazy" decoding="async">
      <img class="gimg" src="images/gallery/2026-01-09_kabuto (7).jpg" alt="" loading="lazy" decoding="async">
      <img class="gimg" src="images/gallery/2026-01-09_kabuto (8).jpg" alt="" loading="lazy" decoding="async">
    </div>

    <p style="margin-top:40px;">
      <a href="index.html">← Homeへ戻る</a>
    </p>
  </main>
 <!-- Lightbox -->
<div id="lightbox" class="lightbox" aria-hidden="true">
  <button class="lightbox-btn prev" id="lightboxPrev" aria-label="Prev">‹</button>

  <figure class="lightbox-figure">
    <button class="lightbox-close" id="lightboxClose" aria-label="Close">×</button>
    <img id="lightboxImg" alt="">
    <figcaption id="lightboxCap" class="lightbox-cap"></figcaption>
  </figure>

  <button class="lightbox-btn next" id="lightboxNext" aria-label="Next">›</button>
</div>
<script>
  const lightbox = document.getElementById("lightbox");
  const lightboxImg = document.getElementById("lightboxImg");
  const lightboxCap = document.getElementById("lightboxCap");
  const closeBtn = document.getElementById("lightboxClose");
  const prevBtn = document.getElementById("lightboxPrev");
  const nextBtn = document.getElementById("lightboxNext");

  const images = Array.from(document.querySelectorAll(".gimg"));
  let currentIndex = -1;

  // ===== Zoom state (showAt/closeLightbox より前に必要) =====
  let scale = 1;
  let panX = 0, panY = 0;

  let isPanning = false;
  let startX = 0, startY = 0;

  let pinching = false;
  let pinchStartDist = 0;
  let pinchStartScale = 1;
  let pinchImgX = 0, pinchImgY = 0;

  const clamp = (v, min, max) => Math.min(max, Math.max(min, v));

  function applyTransform() {
    lightboxImg.classList.toggle("zoomed", scale > 1.01);
    lightboxImg.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
  }

  function resetZoom() {
    scale = 1;
    panX = 0; panY = 0;
    applyTransform();
  }

  // ===== Gallery navigation =====
  function showAt(index) {
    if (!images.length) return;

    resetZoom(); // 画像切り替え時にズーム解除

    currentIndex = (index + images.length) % images.length;
    const img = images[currentIndex];
    lightboxImg.src = img.src;
    const c = img.dataset.cultivar || "";
const d = img.dataset.date || "";
const a = img.dataset.author || "";
lightboxCap.textContent = [c, d, a ? `by ${a}` : ""].filter(Boolean).join(" / ");

  }

  function openLightbox(index) {
    lightbox.classList.add("open");
    lightbox.setAttribute("aria-hidden", "false");
    showAt(index);
  }

  function closeLightbox() {
    resetZoom(); // 閉じる時もズーム解除
    lightbox.classList.remove("open");
    lightbox.setAttribute("aria-hidden", "true");
    lightboxImg.src = "";
    currentIndex = -1;
  }

  function next() { if (currentIndex !== -1) showAt(currentIndex + 1); }
  function prev() { if (currentIndex !== -1) showAt(currentIndex - 1); }

  images.forEach((img, i) => img.addEventListener("click", () => openLightbox(i)));
  nextBtn.addEventListener("click", next);
  prevBtn.addEventListener("click", prev);
  closeBtn.addEventListener("click", closeLightbox);

  // 背景クリックで閉じる
  lightbox.addEventListener("click", (e) => {
    if (e.target === lightbox) closeLightbox();
  });

  // 画像の左右クリックで移動（ズーム中は無効）
  lightboxImg.addEventListener("click", (e) => {
    if (scale > 1.01) return;
    const rect = lightboxImg.getBoundingClientRect();
    const x = e.clientX - rect.left;
    if (x < rect.width / 2) prev();
    else next();
  });

  // キーボード操作（ズーム中は左右無効）
  document.addEventListener("keydown", (e) => {
    if (!lightbox.classList.contains("open")) return;
    if (e.key === "Escape") closeLightbox();
    if (scale > 1.01) return;
    if (e.key === "ArrowRight") next();
    if (e.key === "ArrowLeft") prev();
  });

  // ===== Swipe (mobile) : ズーム中/2本指は無効 =====
  let touchStartX = 0, touchStartY = 0, touchEndX = 0, touchEndY = 0;

  function handleSwipe() {
    const dx = touchEndX - touchStartX;
    const dy = touchEndY - touchStartY;
    if (Math.abs(dx) < 40 || Math.abs(dx) < Math.abs(dy)) return;
    if (dx < 0) next();
    else prev();
  }

  lightbox.addEventListener("touchstart", (e) => {
    if (!lightbox.classList.contains("open")) return;
    if (scale > 1.01 || e.touches.length > 1) return;
    touchStartX = e.changedTouches[0].screenX;
    touchStartY = e.changedTouches[0].screenY;
  }, { passive: true });

  lightbox.addEventListener("touchend", (e) => {
    if (!lightbox.classList.contains("open")) return;
    if (scale > 1.01) return;
    touchEndX = e.changedTouches[0].screenX;
    touchEndY = e.changedTouches[0].screenY;
    handleSwipe();
  }, { passive: true });
function toggleZoomAt(x, y) {
  const rect = lightboxImg.getBoundingClientRect();
  const px = x - rect.left;
  const py = y - rect.top;

  if (scale > 1.01) {
    resetZoom();
    return;
  }

  const newScale = 2;
  const imgX = (px - panX) / scale;
  const imgY = (py - panY) / scale;

  scale = newScale;
  panX = px - imgX * scale;
  panY = py - imgY * scale;

  applyTransform();
}

// ダブルクリックでズーム
lightboxImg.addEventListener("dblclick", (e) => {
  e.preventDefault();
  toggleZoomAt(e.clientX, e.clientY);
});
// スマホ：ダブルタップでズーム
let lastTap = 0;
lightboxImg.addEventListener("touchend", (e) => {
  if (!lightbox.classList.contains("open")) return;
  if (e.changedTouches.length !== 1) return;
  if (pinching) return;          // ピンチ中は無視
  if (scale > 1.01 && isPanning) return; // パン中も無視

  const now = Date.now();
  const dt = now - lastTap;

  if (dt < 280 && dt > 30) {
    const t = e.changedTouches[0];
    toggleZoomAt(t.clientX, t.clientY);
    lastTap = 0;
  } else {
    lastTap = now;
  }
}, { passive: true });

// マウスホイールでズーム
lightboxImg.addEventListener("wheel", (e) => {
  if (!lightbox.classList.contains("open")) return;

  e.preventDefault();

  const rect = lightboxImg.getBoundingClientRect();
  const px = e.clientX - rect.left;
  const py = e.clientY - rect.top;

  const imgX = (px - panX) / scale;
  const imgY = (py - panY) / scale;

  const zoomFactor = e.deltaY < 0 ? 1.12 : 1 / 1.12;
  scale = clamp(scale * zoomFactor, 1, 6);

  panX = px - imgX * scale;
  panY = py - imgY * scale;

  applyTransform();

  // ★ここは「戻りすぎる」なら消してOK
  // if (scale <= 1.01) resetZoom();
}, { passive: false });

// ドラッグで移動（PC）
let mousePanning = false;
let mouseStartX = 0, mouseStartY = 0;

lightboxImg.addEventListener("mousedown", (e) => {
  if (scale <= 1.01) return;
  mousePanning = true;
  mouseStartX = e.clientX - panX;
  mouseStartY = e.clientY - panY;
});

document.addEventListener("mousemove", (e) => {
  if (!mousePanning) return;
  panX = e.clientX - mouseStartX;
  panY = e.clientY - mouseStartY;
  applyTransform();
});

document.addEventListener("mouseup", () => {
  mousePanning = false;
});

  // ===== Pinch zoom + pan =====
  function dist(t1, t2) {
    const dx = t2.clientX - t1.clientX;
    const dy = t2.clientY - t1.clientY;
    return Math.hypot(dx, dy);
  }
  function mid(t1, t2) {
    return { x: (t1.clientX + t2.clientX) / 2, y: (t1.clientY + t2.clientY) / 2 };
  }

  lightboxImg.addEventListener("touchstart", (e) => {
    if (e.touches.length === 2) {
      pinching = true;
      isPanning = false;

      const t1 = e.touches[0], t2 = e.touches[1];
      pinchStartDist = dist(t1, t2);
      pinchStartScale = scale;

      const m = mid(t1, t2);
      pinchImgX = (m.x - panX) / scale;
      pinchImgY = (m.y - panY) / scale;
    } else if (e.touches.length === 1 && scale > 1.01) {
      pinching = false;
      isPanning = true;
      startX = e.touches[0].clientX - panX;
      startY = e.touches[0].clientY - panY;
    }
  }, { passive: true });

  lightboxImg.addEventListener("touchmove", (e) => {
    if (pinching && e.touches.length === 2) {
      e.preventDefault();
      const t1 = e.touches[0], t2 = e.touches[1];
      const ratio = dist(t1, t2) / pinchStartDist;

      scale = clamp(pinchStartScale * ratio, 1, 4);

      const m = mid(t1, t2);
      panX = m.x - pinchImgX * scale;
      panY = m.y - pinchImgY * scale;

      applyTransform();
    } else if (isPanning && e.touches.length === 1) {
      panX = e.touches[0].clientX - startX;
      panY = e.touches[0].clientY - startY;
      applyTransform();
    }
  }, { passive: false });

  lightboxImg.addEventListener("touchend", (e) => {
    if (e.touches.length < 2) pinching = false;
    if (e.touches.length === 0) isPanning = false;
    if (scale <= 1.01) resetZoom();
  }, { passive: true });
</script>



</body>
</html>
